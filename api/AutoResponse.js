const axios = require('axios');

// Áí∞Â¢ÉÂ§âÊï∞„Åã„Çâ„Ç¢„ÇØ„Çª„Çπ„Éà„Éº„ÇØ„É≥„ÇíÂèñÂæó
const PAGE_ACCESS_TOKEN = process.env.PAGE_ACCESS_TOKEN || "IGAAX69AxSy9JBZAFFyemdlV1pPWDNMN0tPaTJFSmNzTWEtWk5xcHV3ZAGhRd1g1X3o4eFBPWEJ3ZAHVZAWHBfSmxOTXFGUExlZAGRvdTExM2hhMkJqMlFjOGl6d1RTbmkzZAnFoWHpidXYtTnZAzcGlVUG9mSGV2SDVOdUFXcEQ2ekxuRQZDZD";

// „Éà„Éº„ÇØ„É≥Ê§úË®ºÁî®„ÅÆÂ§âÊï∞
let tokenValidated = false;
let tokenValidationError = null;

// „É°„ÉÉ„Çª„Éº„Ç∏ÈáçË§áÈò≤Ê≠¢Áî®„ÅÆ„É°„É¢„É™„Çπ„Éà„É¨„Éº„Ç∏
const messageHistory = new Map();

// Ë®≠ÂÆö„Éá„Éº„ÇøÔºàÊú¨Êù•„ÅØ„Éá„Éº„Çø„Éô„Éº„Çπ„Çí‰ΩøÁî®Ôºâ
let botConfig = {
  triggerType: "all",
  triggerKeywords: "",
  excludeWords: false,
  excludeKeywords: "",
  firstTimeOnly: false,
  businessHoursOnly: false,
  actionTiming: "immediate",
  duplicateMessages: true,
  preventDuplicates: true,
  responses: [
    { condition: 'hello', message: 'Hello! How can I help you?', trigger: 'Êå®Êã∂' },
    { condition: '„Åì„Çì„Å´„Å°„ÅØ', message: '„Åì„Çì„Å´„Å°„ÅØ!‰Ωï„Åã„ÅäÊâã‰ºù„ÅÑ„Åß„Åç„Çã„Åì„Å®„ÅØ„ÅÇ„Çä„Åæ„Åô„Åã?', trigger: 'Êå®Êã∂' },
    { condition: '„Éò„É´„Éó', message: '„ÅîË≥™Âïè„ÇÑ„ÅäÂõ∞„Çä„ÅÆ„Åì„Å®„Åå„ÅÇ„Çå„Å∞„ÄÅ„ÅäÊ∞óËªΩ„Å´„ÅäËÅû„Åã„Åõ„Åè„Å†„Åï„ÅÑ!', trigger: '„Éò„É´„Éó' },
    { condition: '„ÅÇ„Çä„Åå„Å®„ÅÜ', message: '„Å©„ÅÜ„ÅÑ„Åü„Åó„Åæ„Åó„Å¶!‰ªñ„Å´‰Ωï„Åã„ÅäÊâã‰ºù„ÅÑ„Åß„Åç„Çã„Åì„Å®„ÅØ„ÅÇ„Çä„Åæ„Åô„Åã?', trigger: '„ÅäÁ§º' }
  ]
};

/**
 * ÈáçË§á„ÉÅ„Çß„ÉÉ„ÇØÈñ¢Êï∞Ôºà1ÂàÜ‰ª•ÂÜÖ„ÅÆÂêå„Åò„É°„ÉÉ„Çª„Éº„Ç∏„Çí„ÉÅ„Çß„ÉÉ„ÇØÔºâ
 */
function isDuplicateMessage(senderId, text) {
  const now = Date.now();
  const oneMinuteAgo = now - 60 * 1000;
  
  if (!messageHistory.has(senderId)) {
    messageHistory.set(senderId, []);
  }
  
  const userMessages = messageHistory.get(senderId);
  const filteredMessages = userMessages.filter(msg => msg.timestamp > oneMinuteAgo);
  messageHistory.set(senderId, filteredMessages);
  
  const duplicate = filteredMessages.some(msg => 
    msg.text === text && msg.timestamp > oneMinuteAgo
  );
  
  if (!duplicate) {
    filteredMessages.push({ text, timestamp: now });
    messageHistory.set(senderId, filteredMessages);
  }
  
  return duplicate;
}

/**
 * „Éà„Éº„ÇØ„É≥„ÅÆÊúâÂäπÊÄß„ÇíÊ§úË®º„Åô„ÇãÈñ¢Êï∞
 */
async function validateToken() {
  if (!PAGE_ACCESS_TOKEN) {
    console.log('‚ùå PAGE_ACCESS_TOKEN is not set!');
    tokenValidationError = 'Token not configured';
    return false;
  }
  
  try {
    console.log('üîê Validating access token...');
    const response = await axios.get('https://graph.instagram.com/v21.0/me', {
      params: { 
        access_token: PAGE_ACCESS_TOKEN,
        fields: 'id,username'
      }
    });
    
    console.log('‚úÖ Token validated successfully!');
    console.log('üì± Instagram Account:', response.data);
    tokenValidated = true;
    tokenValidationError = null;
    return true;
  } catch (error) {
    console.log('‚ùå Token validation failed!');
    console.log('üîç Error details:', {
      status: error.response?.status,
      message: error.response?.data?.error?.message || error.message,
      code: error.response?.data?.error?.code,
      type: error.response?.data?.error?.type
    });
    
    tokenValidated = false;
    tokenValidationError = error.response?.data?.error?.message || error.message;
    
    if (error.response?.status === 400) {
      console.log('‚ö†Ô∏è Token appears to be invalid or malformed');
    } else if (error.response?.status === 401 || error.response?.status === 403) {
      console.log('‚ö†Ô∏è Token expired or insufficient permissions');
      console.log('üí° Please generate a new token at: https://developers.facebook.com/');
    } else if (error.response?.status === 190) {
      console.log('‚ö†Ô∏è Token has expired - please renew it');
    }
    
    return false;
  }
}

/**
 * DMÈÄÅ‰ø°Èñ¢Êï∞
 */
async function sendDM(recipientId, message, messageNumber = '') {
  console.log(`üì§ Attempting to send DM${messageNumber} to ${recipientId}: "${message}"`);
  
  if (!PAGE_ACCESS_TOKEN) {
    console.log('‚ùå PAGE_ACCESS_TOKEN is not set!');
    return null;
  }
  
  if (!tokenValidated) {
    console.log('‚ö†Ô∏è Token not validated, attempting validation...');
    const isValid = await validateToken();
    if (!isValid) {
      console.log('‚ùå Cannot send DM: Token validation failed');
      console.log('‚ùå Error:', tokenValidationError);
      return null;
    }
  }
  
  try {
    const response = await axios.post(`https://graph.instagram.com/v21.0/me/messages`, {
      recipient: { id: recipientId },
      message: { text: message }
    }, {
      params: { access_token: PAGE_ACCESS_TOKEN },
      headers: { 'Content-Type': 'application/json' }
    });
    
    console.log(`‚úÖ DM${messageNumber} sent successfully:`, response.data);
    return response.data;
  } catch (error) {
    console.log(`‚ùå Failed to send DM${messageNumber}:`, error.response?.data || error.message);
    console.log(`üîç Error details:`, {
      status: error.response?.status,
      data: error.response?.data,
      token: PAGE_ACCESS_TOKEN ? PAGE_ACCESS_TOKEN.substring(0, 20) + '...' : 'Not set'
    });
    
    if (error.response?.status === 401 || error.response?.status === 403 || error.response?.status === 190) {
      console.log('üîÑ Token may be expired, marking for revalidation...');
      tokenValidated = false;
      await validateToken();
    }
    
    return null;
  }
}

/**
 * ÂãïÁöÑ„Å™Ëøî‰ø°„É°„ÉÉ„Çª„Éº„Ç∏Ê±∫ÂÆöÈñ¢Êï∞
 */
function getReplyMessage(text) {
  let reply = `Echo: ${text}`;

  for (const response of botConfig.responses) {
    if (response.condition === 'default') {
      reply = response.message;
      continue;
    }

    if (text && text.toLowerCase().includes(response.condition.toLowerCase())) {
      reply = response.message;
      console.log(`üéØ Matched condition: ${response.condition}`);
      break;
    }
  }

  // Èô§Â§ñ„ÉØ„Éº„ÉâÊ©üËÉΩ
  if (botConfig.excludeWords && botConfig.excludeKeywords) {
    const excludeList = botConfig.excludeKeywords.split(',').map(word => word.trim());
    for (const excludeWord of excludeList) {
      if (text && text.toLowerCase().includes(excludeWord.toLowerCase())) {
        console.log(`üö´ Excluded by word: ${excludeWord}`);
        return null;
      }
    }
  }

  // „Éà„É™„Ç¨„Éº„Çø„Ç§„Éó„ÉÅ„Çß„ÉÉ„ÇØ
  if (botConfig.triggerType === 'keyword' && botConfig.triggerKeywords) {
    const triggerList = botConfig.triggerKeywords.split(',').map(word => word.trim());
    let shouldReply = false;
    
    for (const trigger of triggerList) {
      if (text && text.toLowerCase().includes(trigger.toLowerCase())) {
        shouldReply = true;
        break;
      }
    }
    
    if (!shouldReply) {
      console.log(`üö´ No trigger keyword matched`);
      return null;
    }
  }

  return reply;
}

/**
 * „É°„ÉÉ„Çª„Éº„Ç∏Âá¶ÁêÜÈñ¢Êï∞ÔºàË§áË£Ω„Å®ÈáçË§áÈò≤Ê≠¢Ê©üËÉΩ‰ªò„ÅçÔºâ
 */
function processMessage(senderId, text, messageIndex = 1, totalMessages = 1) {
  console.log(`\nüì© Processing Message ${messageIndex}/${totalMessages} (1 second delayed)`);
  console.log(`‚úâÔ∏è Message from ${senderId}: "${text}"`);
  
  if (isDuplicateMessage(senderId, text)) {
    console.log(`üö´ Duplicate message detected within 1 minute - skipping message ${messageIndex}`);
    return;
  }
  
  console.log(`üîß Using config: ${JSON.stringify(botConfig, null, 2)}`);
  console.log(`üîê Token validated: ${tokenValidated}`);
  
  const reply = getReplyMessage(text);
  
  if (reply) {
    console.log(`üí≠ Reply ${messageIndex}: "${reply}"`);
    
    const delay = botConfig.actionTiming === 'immediate' ? 0 : 
                botConfig.actionTiming === 'delay-5' ? 5 * 60 * 1000 :
                botConfig.actionTiming === 'delay-10' ? 10 * 60 * 1000 :
                botConfig.actionTiming === 'delay-30' ? 30 * 60 * 1000 :
                botConfig.actionTiming === 'delay-60' ? 60 * 60 * 1000 : 0;
    
    if (delay > 0) {
      console.log(`‚è∞ Scheduling reply ${messageIndex} in ${delay / 1000} seconds`);
      setTimeout(() => {
        sendDM(senderId, reply, ` #${messageIndex}`);
      }, delay);
    } else {
      sendDM(senderId, reply, ` #${messageIndex}`);
    }
  } else {
    console.log(`üö´ No reply sent for message ${messageIndex} (filtered by configuration)`);
  }
}

/**
 * Webhook„É°„ÉÉ„Çª„Éº„Ç∏Âá¶ÁêÜÔºà„É°„Ç§„É≥„Éè„É≥„Éâ„É©„ÉºÔºâ
 */
function handleWebhookMessage(body) {
  console.log('\nüéØ ==> AutoResponse Handler Started <==');
  console.log('üì¶ Request received');
  console.log('üìã Body:', JSON.stringify(body, null, 2));

  if (body && body.object === 'instagram') {
    console.log('‚úÖ Instagram object detected');
    
    if (body.entry && Array.isArray(body.entry)) {
      console.log(`üì¶ Processing ${body.entry.length} entries`);
      
      body.entry.forEach((entry, entryIndex) => {
        console.log(`\nüì¶ Entry ${entryIndex + 1}:`);
        
        if (entry.messaging && Array.isArray(entry.messaging)) {
          console.log(`üí¨ Found ${entry.messaging.length} messaging events`);
          
          entry.messaging.forEach((event, eventIndex) => {
            console.log(`\nüì© Event ${eventIndex + 1}:`);
            
            if (event.message && event.sender && event.sender.id) {
              const senderId = event.sender.id;
              const text = event.message.text;
              
              console.log(`üì® Original message from ${senderId}: "${text}"`);
              console.log('üîÑ Message duplication ALWAYS ENABLED - processing after 1 second delay...');
              
              // 1ÁßíÂæå„Å´1„Å§ÁõÆ„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏Âá¶ÁêÜ
              setTimeout(() => {
                processMessage(senderId, text, 1, 2);
              }, 1000);
              
              // 1.1ÁßíÂæå„Å´2„Å§ÁõÆ„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏Âá¶ÁêÜ
              setTimeout(() => {
                processMessage(senderId, text, 2, 2);
              }, 1100);
            }
          });
        }
      });
    }
  } else {
    console.log('‚ùå Not an Instagram object or invalid body');
  }
  
  console.log('üéØ ==> AutoResponse Handler Completed <==\n');
}

/**
 * Ë®≠ÂÆö„ÇíÂèñÂæó
 */
function getConfig() {
  return botConfig;
}

/**
 * Ë®≠ÂÆö„ÇíÊõ¥Êñ∞
 */
function updateConfig(newConfig) {
  const updatedConfig = { ...botConfig, ...newConfig };
  updatedConfig.duplicateMessages = true;
  updatedConfig.preventDuplicates = true;
  botConfig = updatedConfig;
  
  console.log('‚úÖ Configuration updated successfully');
  console.log('üîß New config applied:', JSON.stringify(botConfig, null, 2));
  
  return botConfig;
}

/**
 * „É°„ÉÉ„Çª„Éº„Ç∏Â±•Ê≠¥„Çí„ÇØ„É™„Ç¢
 */
function clearMessageHistory() {
  messageHistory.clear();
  console.log('üßπ Message history cleared');
}

/**
 * „Çπ„ÉÜ„Éº„Çø„ÇπÊÉÖÂ†±„ÇíÂèñÂæó
 */
function getStatus() {
  return {
    tokenValidated,
    tokenValidationError,
    messageHistorySize: messageHistory.size,
    config: botConfig,
    tokenConfigured: !!PAGE_ACCESS_TOKEN
  };
}

// Ëµ∑ÂãïÊôÇ„Å´„Éà„Éº„ÇØ„É≥„ÇíÊ§úË®º
validateToken().then(isValid => {
  if (isValid) {
    console.log('üéâ AutoResponse module ready!');
  } else {
    console.log('‚ö†Ô∏è WARNING: AutoResponse started but token validation failed');
  }
});

// „É¢„Ç∏„É•„Éº„É´„ÅÆ„Ç®„ÇØ„Çπ„Éù„Éº„Éà
module.exports = {
  handleWebhookMessage,
  validateToken,
  getConfig,
  updateConfig,
  clearMessageHistory,
  getStatus,
  sendDM,
  processMessage,
  isDuplicateMessage,
  getReplyMessage
};
